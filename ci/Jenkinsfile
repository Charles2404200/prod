pipeline {
  agent any
  options {
    skipDefaultCheckout(true)
  }

  parameters {
    string(name: 'GHCR_NAMESPACE',  defaultValue: 'BennyBach1002', description: 'GitHub user/org (lowercased for Docker)')
    string(name: 'BRANCH_TO_BUILD', defaultValue: 'ansible-prod',  description: 'Git branch to build')
    string(name: 'DEPLOY_LIMIT',    defaultValue: 'lb,staging',    description: 'Ansible --limit (e.g. "lb,staging" or "lb,prod")')
    booleanParam(name: 'DOCKER_SWARM', defaultValue: false, description: 'Run the Docker Swarm deploy stage (leave off if not set up)')
  }

  environment {
    APP_NAME = 'rmit-store'

    // Repo
    REPO_URL = 'https://github.com/Charles2404200/prod'

    // Ansible inside repo
    INVENTORY_PATH = 'infra/ansible/inventory.ini'
    PLAYBOOK_PATH  = 'infra/ansible/site.yml'

    // Controller EC2 (where Ansible runs)
    CTRL_HOST   = '34.227.19.111'
    CTRL_USER   = 'ec2-user'
    REMOTE_WORK = '/home/ec2-user/deploy'

    // App runtime config
    FRONTEND_DOMAIN = '34.227.19.111'         // where UI should be reachable
    JWT_SECRET = 'my_secret_string'
    MONGO_URI  = 'mongodb+srv://RMIT_Store:123RMIT@ac-mr6vgxa-shard-00-00.uvixzgs.mongodb.net/admin?authSource=admin&replicaSet=atlas-gbr5dj-shard-0&retryWrites=true&w=majority&appName=RMITStore'

    NGINX_IMG = 'nginx:1.27-alpine'
  }

  stages {

    stage('Checkout') {
      steps {
        sh 'rm -rf ws && mkdir -p ws'
        checkout([$class: 'GitSCM',
          branches: [[name: "*/${params.BRANCH_TO_BUILD}"]],
          userRemoteConfigs: [[url: "${env.REPO_URL}"]],
          extensions: [[ $class: 'RelativeTargetDirectory', relativeTargetDir: 'ws' ]]
        ])
        sh 'ls -la ws | head -n 30'
      }
    }

    stage('Resolve Image Names & Tag') {
      steps {
        script {
          def ns = params.GHCR_NAMESPACE.trim().toLowerCase()
          env.FE_IMG = "ghcr.io/${ns}/rmit-store-frontend".toLowerCase()
          env.BE_IMG = "ghcr.io/${ns}/rmit-store-backend".toLowerCase()
          env.IMAGE_TAG = sh(returnStdout: true, script: 'cd ws && git rev-parse --short HEAD').trim()
          if (!env.IMAGE_TAG) { env.IMAGE_TAG = "build-${env.BUILD_NUMBER}" }
          echo "FE_IMG=${env.FE_IMG}"
          echo "BE_IMG=${env.BE_IMG}"
          echo "IMAGE_TAG=${env.IMAGE_TAG}"
        }
      }
    }

    stage('Login to GHCR') {
      steps {
        withCredentials([ usernamePassword(credentialsId: 'GHCR_USER',
                                           usernameVariable: 'GH_USER',
                                           passwordVariable: 'GH_TOKEN') ]) {
          sh 'echo "$GH_TOKEN" | docker login ghcr.io -u "$GH_USER" --password-stdin'
        }
      }
    }

stage('Build & push images (BE/FE)') {
  steps {
    script {
      // sanitize namespace once more (in case parameter is an email)
      def ns = params.GHCR_NAMESPACE.toLowerCase().replaceAll(/[^a-z0-9-]/, '')
      env.BACKEND_IMAGE  = "ghcr.io/${ns}/rmit-store-backend"
      env.FRONTEND_IMAGE = "ghcr.io/${ns}/rmit-store-frontend"

      withCredentials([usernamePassword(credentialsId: 'GHCR_USER',
                                        usernameVariable: 'GH_USER',
                                        passwordVariable: 'GH_TOKEN')]) {
        dir('ws') {                       // <<< important: work in the repo dir
          sh """
          set -euo pipefail
          echo "\\n[debug] PWD=\$(pwd); ls -la; echo; ls -la ci || true; ls -la client || true"

          echo "\$GH_TOKEN" | docker login ghcr.io -u "\$GH_USER" --password-stdin

          echo "[build] Backend -> ${BACKEND_IMAGE}:${IMAGE_TAG}"
          docker build -t ${BACKEND_IMAGE}:${IMAGE_TAG} -f ci/Dockerfile.backend .

          echo "[tag/push] ${BACKEND_IMAGE}"
          docker tag  ${BACKEND_IMAGE}:${IMAGE_TAG} ${BACKEND_IMAGE}:latest
          docker push ${BACKEND_IMAGE}:${IMAGE_TAG}
          docker push ${BACKEND_IMAGE}:latest

          echo "[build] Frontend -> ${FRONTEND_IMAGE}:${IMAGE_TAG}"
          docker build -t ${FRONTEND_IMAGE}:${IMAGE_TAG} -f ci/Dockerfile.frontend client

          echo "[tag/push] ${FRONTEND_IMAGE}"
          docker tag  ${FRONTEND_IMAGE}:${IMAGE_TAG} ${FRONTEND_IMAGE}:latest
          docker push ${FRONTEND_IMAGE}:${IMAGE_TAG}
          docker push ${FRONTEND_IMAGE}:latest
          """
        }
      }
    }
  }
}

  } // stages

  post {
    success { echo "✅ ${env.APP_NAME} ${env.IMAGE_TAG} built & deployed (Ansible). Swarm: ${params.DOCKER_SWARM ? 'ON' : 'OFF'}" }
    failure { echo "❌ Pipeline failed. Check logs above." }
    always  { echo "Build URL: ${env.BUILD_URL}" }
  }
}
