pipeline {
  agent any
  options { skipDefaultCheckout(true) }

  parameters {
    string(name: 'GHCR_NAMESPACE',  defaultValue: 'BennyBach1002', description: 'GitHub user/org (lowercased for Docker)')
    string(name: 'BRANCH_TO_BUILD', defaultValue: 'ansible-prod',  description: 'Git branch to build')
  }

  environment {
    // App / repo
    APP_NAME   = 'rmit-store'
    REPO_URL   = 'https://github.com/Charles2404200/prod'

    // Target host (where we will run containers)
    CTRL_HOST  = '34.227.19.111'
    CTRL_USER  = 'ec2-user'

    // App config for runtime
    FRONTEND_DOMAIN = '34.227.19.111'
    JWT_SECRET = 'my_secret_string'
    MONGO_URI  = 'mongodb+srv://RMIT_Store:123RMIT@ac-mr6vgxa-shard-00-00.uvixzgs.mongodb.net/admin?authSource=admin&replicaSet=atlas-gbr5dj-shard-0&retryWrites=true&w=majority&appName=RMITStore'

    // Will be set in “Resolve” stage so they’re visible everywhere (incl. post{})
    BACKEND_IMAGE  = "ghcr.io/${params.GHCR_NAMESPACE}/rmit-store-backend"
    FRONTEND_IMAGE = "ghcr.io/${params.GHCR_NAMESPACE}/rmit-store-frontend"
    DB_IMAGE       = "ghcr.io/${params.GHCR_NAMESPACE}/rmit-store-db"
  }

  stages {

    stage('Checkout') {
      steps {
        sh 'rm -rf ws && mkdir -p ws'
        checkout([$class: 'GitSCM',
          branches: [[name: "*/${params.BRANCH_TO_BUILD}"]],
          userRemoteConfigs: [[url: "${env.REPO_URL}"]],
          extensions: [[ $class: 'RelativeTargetDirectory', relativeTargetDir: 'ws' ]]
        ])
        sh 'ls -la ws | head -n 30'
      }
    }

    stage('Resolve Image Names & Tag') {
      steps {
        script {
          def ns = params.GHCR_NAMESPACE.trim().toLowerCase().replaceAll(/[^a-z0-9-]/, '')
          env.FRONTEND_IMAGE = "ghcr.io/${ns}/rmit-store-frontend".toLowerCase()
          env.BACKEND_IMAGE  = "ghcr.io/${ns}/rmit-store-backend".toLowerCase()
          env.IMAGE_TAG = sh(returnStdout: true, script: 'cd ws && git rev-parse --short HEAD').trim()
          if (!env.IMAGE_TAG) { env.IMAGE_TAG = "build-${env.BUILD_NUMBER}" }
          echo "FRONTEND_IMAGE=${env.FRONTEND_IMAGE}"
          echo "BACKEND_IMAGE=${env.BACKEND_IMAGE}"
          echo "IMAGE_TAG=${env.IMAGE_TAG}"
        }
      }
    }

    stage('Login to GHCR') {
      steps {
        withCredentials([ usernamePassword(credentialsId: 'GHCR_USER',
                                           usernameVariable: 'GH_USER',
                                           passwordVariable: 'GH_TOKEN') ]) {
          sh 'echo "$GH_TOKEN" | docker login ghcr.io -u "$GH_USER" --password-stdin'
        }
      }
    }

    stage('Build & Push Images (BE/FE)') {
      steps {
        withCredentials([ usernamePassword(credentialsId: 'GHCR_USER',
                                           usernameVariable: 'GH_USER',
                                           passwordVariable: 'GH_TOKEN') ]) {
          dir('ws') {
            sh '''#!/usr/bin/env bash
set -euo pipefail

echo "[debug] repo tree:"
ls -la; echo; ls -la ci || true; ls -la client || true

echo "$GH_TOKEN" | docker login ghcr.io -u "$GH_USER" --password-stdin

echo "[build] Backend -> $BACKEND_IMAGE:$IMAGE_TAG"
docker build -t "$BACKEND_IMAGE:$IMAGE_TAG" -f ci/Dockerfile.backend .

echo "[push] $BACKEND_IMAGE:$IMAGE_TAG"
docker push "$BACKEND_IMAGE:$IMAGE_TAG"

echo "[build] Frontend -> $FRONTEND_IMAGE:$IMAGE_TAG"
docker build -t "$FRONTEND_IMAGE:$IMAGE_TAG" -f ci/Dockerfile.frontend .

echo "[push] $FRONTEND_IMAGE:$IMAGE_TAG"
docker push "$FRONTEND_IMAGE:$IMAGE_TAG"
'''
          }
        }
      }
    }

    stage('Deploy to EC2 (34.227.19.111)') {
      steps {
        withCredentials([
          usernamePassword(credentialsId: 'GHCR_USER', usernameVariable: 'GH_USER', passwordVariable: 'GH_TOKEN'),
          sshUserPrivateKey(credentialsId: 'ansible-ec2-key', keyFileVariable: 'SSH_KEY')
        ]) {
          sh '''#!/usr/bin/env bash
set -euo pipefail
chmod 600 "$SSH_KEY"

echo "[deploy] SSH into $CTRL_USER@$CTRL_HOST"
ssh -o StrictHostKeyChecking=no -i "$SSH_KEY" "$CTRL_USER@$CTRL_HOST" bash -s <<'REMOTE'
set -euo pipefail

# ---- Ensure Docker + Compose ----
if ! command -v docker >/dev/null 2>&1; then
  if command -v yum >/dev/null 2>&1; then
    sudo yum update -y
    sudo amazon-linux-extras enable docker || true
    sudo yum install -y docker
    sudo systemctl enable --now docker
  elif command -v apt-get >/dev/null 2>&1; then
    sudo apt-get update -y
    sudo apt-get install -y docker.io
    sudo systemctl enable --now docker
  fi
  sudo usermod -aG docker "$USER" || true
fi

mkdir -p ~/.docker/cli-plugins/
if ! docker compose version >/dev/null 2>&1; then
  curl -SL https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64 \
    -o ~/.docker/cli-plugins/docker-compose
  chmod +x ~/.docker/cli-plugins/docker-compose
fi

REMOTE
'''

          // We need variable expansion from Jenkins here -> use unquoted heredoc (not 'REMOTE')
          sh '''#!/usr/bin/env bash
set -euo pipefail

ssh -o StrictHostKeyChecking=no -i "$SSH_KEY" "$CTRL_USER@$CTRL_HOST" bash -s <<EOF
set -euo pipefail

echo "[docker] Login GHCR"
echo "$GH_TOKEN" | docker login ghcr.io -u "$GH_USER" --password-stdin

echo "[compose] Write docker-compose.yml"
mkdir -p ~/deploy
cat > ~/deploy/docker-compose.yml <<YAML
version: "3.8"
services:
  backend:
    image: $BACKEND_IMAGE:$IMAGE_TAG
    environment:
      MONGO_URI: $MONGO_URI
      JWT_SECRET: $JWT_SECRET
      PORT: 3000
    ports:
      - "3000:3000"
    restart: unless-stopped

  frontend:
    image: $FRONTEND_IMAGE:$IMAGE_TAG
    environment:
      VITE_API_BASE: http://$FRONTEND_DOMAIN:3000
    ports:
      - "80:80"
    depends_on:
      - backend
    restart: unless-stopped
YAML

echo "[compose] Up"
cd ~/deploy
docker compose pull
docker compose up -d

echo "[health] curl http://$FRONTEND_DOMAIN/"
for i in {1..30}; do
  code=$(curl -sS -o /dev/null -w "%{http_code}" "http://$FRONTEND_DOMAIN/" || true)
  [[ "$code" =~ ^2|3 ]] && { echo "OK HTTP $code"; exit 0; }
  echo "wait($i) -> $code"; sleep 2
done
echo "ERROR: site not healthy"
exit 1
EOF
'''
        }
      }
    }

  } // stages

  post {
    success {
      echo """
✅ ${env.APP_NAME} deployed successfully

Build:     ${env.BUILD_URL}
Branch:    ${params.BRANCH_TO_BUILD}
Tag:       ${env.IMAGE_TAG}

Frontend:  http://${env.FRONTEND_DOMAIN}
API:       http://${env.FRONTEND_DOMAIN}:3000

Images:
  - ${env.FRONTEND_IMAGE}:${env.IMAGE_TAG}
  - ${env.BACKEND_IMAGE}:${env.IMAGE_TAG}
"""
    }
    failure { echo "❌ Pipeline failed. See console log: ${env.BUILD_URL}console" }
    always  { echo "Build URL: ${env.BUILD_URL}" }
  }
}
