pipeline {
  agent any
  options { skipDefaultCheckout(true) }

  parameters {
    string(name: 'GHCR_NAMESPACE',  defaultValue: 'BennyBach1002', description: 'GitHub user/org (forced lowercase for Docker)')
    string(name: 'BRANCH_TO_BUILD', defaultValue: 'ansible-prod',  description: 'Git branch to build')
    string(name: 'DEPLOY_LIMIT',    defaultValue: 'lb,staging',    description: 'Ansible --limit (e.g. "lb,staging" or "lb,prod")')
  }

  environment {
    APP_NAME  = 'rmit-store'
    INVENTORY = 'infra/ansible/inventory.ini'
    PLAYBOOK  = 'infra/ansible/site.yml'
  }

  stages {
    stage('Checkout into ws/') {
      steps {
        sh 'rm -rf ws && mkdir -p ws'
        checkout([$class: 'GitSCM',
          branches: [[name: "*/${params.BRANCH_TO_BUILD}"]],
          userRemoteConfigs: [[url: 'https://github.com/Charles2404200/prod']],
          extensions: [[ $class: 'RelativeTargetDirectory', relativeTargetDir: 'ws' ]]
        ])
        sh 'ls -la ws | head -n 30'
      }
    }

    stage('Login to GHCR (controller)') {
      steps {
        withCredentials([ usernamePassword(credentialsId: 'GHCR_USER',
                                           usernameVariable: 'GH_USER',
                                           passwordVariable: 'GH_TOKEN') ]) {
          sh 'echo "$GH_TOKEN" | docker login ghcr.io -u "$GH_USER" --password-stdin'
        }
      }
    }

    stage('Build & Push Images (BE/FE only)') {
      steps {
        dir('ws') {
          script {
            def ns = params.GHCR_NAMESPACE.toLowerCase().replaceAll(/[^a-z0-9-]/, '')
            if (ns != params.GHCR_NAMESPACE) {
              echo "NOTE: sanitized GHCR namespace '${params.GHCR_NAMESPACE}' -> '${ns}'"
            }

            def BACKEND  = "ghcr.io/${ns}/rmit-store-backend"
            def FRONTEND = "ghcr.io/${ns}/rmit-store-frontend"
            def TAG      = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()

            sh """
              set -e
              echo TAG=${TAG}
              echo BE=${BACKEND}
              echo FE=${FRONTEND}

              docker build --pull --no-cache -t ${BACKEND}:${TAG}  -f ci/Dockerfile.backend .
              docker tag ${BACKEND}:${TAG} ${BACKEND}:latest
              docker push ${BACKEND}:${TAG}
              docker push ${BACKEND}:latest

              docker build --pull --no-cache -t ${FRONTEND}:${TAG} -f ci/Dockerfile.frontend .
              docker tag ${FRONTEND}:${TAG} ${FRONTEND}:latest
              docker push ${FRONTEND}:${TAG}
              docker push ${FRONTEND}:latest

              docker image prune -f || true
            """

            env.IMAGE_TAG      = TAG
            env.BACKEND_IMAGE  = BACKEND
            env.FRONTEND_IMAGE = FRONTEND
          }
        }
      }
    }

stage('Deploy with Ansible (Swarm + NGINX)') {
  steps {
    withCredentials([
      usernamePassword(
        credentialsId: 'GHCR_USER',       // GHCR username/password (or PAT as password)
        usernameVariable: 'GH_USER',
        passwordVariable: 'GH_TOKEN'
      ),
      sshUserPrivateKey(
        credentialsId: 'ansible-ec2-key', // SSH key for your target EC2s
        keyFileVariable: 'ANSIBLE_KEY',
        usernameVariable: 'ANSIBLE_SSH_USER' // typically "ec2-user"
      )
    ]) {
      dir('ws') {
        sh '''#!/usr/bin/env bash
set -euo pipefail

# Paths in your repo
INVENTORY="${INVENTORY:-infra/ansible/inventory.ini}"
PLAYBOOK="${PLAYBOOK:-infra/ansible/site.yml}"

# Limit to LB (nginx) and staging app nodes
DEPLOY_LIMIT="${DEPLOY_LIMIT:-lb,staging}"

# Vars consumed by your roles/group_vars
EXTRA_VARS="
  backend_image=${BACKEND_IMAGE}
  frontend_image=${FRONTEND_IMAGE}
  image_tag=${IMAGE_TAG}
  env=staging
  ghcr_user=${GH_USER}
  ghcr_token=${GH_TOKEN}
  docker_user=${ANSIBLE_SSH_USER}
  docker_cli_plugins_dir=/usr/libexec/docker/cli-plugins
  docker_compose_version=v2.27.0
"

echo "→ Using inventory: $INVENTORY"
echo "→ Playbook:        $PLAYBOOK"
echo "→ Limit hosts:     $DEPLOY_LIMIT"
echo "→ Images:"
echo "   - ${BACKEND_IMAGE}:${IMAGE_TAG}"
echo "   - ${FRONTEND_IMAGE}:${IMAGE_TAG}"

# Ensure Ansible present
if ! command -v ansible-playbook >/dev/null 2>&1; then
  if command -v yum >/dev/null 2>&1; then
    sudo yum install -y ansible
  elif command -v apt-get >/dev/null 2>&1; then
    sudo apt-get update && sudo apt-get install -y ansible python3-pip
  else
    echo "Ansible not found and no apt/yum available"; exit 1
  fi
fi

# Install Galaxy collections if declared (e.g., community.docker)
if [[ -f infra/ansible/requirements.yml ]]; then
  ansible-galaxy collection install -r infra/ansible/requirements.yml -p ./collections
fi

chmod 600 "$ANSIBLE_KEY"

# (Optional) quick SSH reachability check against one host from inventory
# awk pulls first non-empty, non-header host from the [staging] or [lb] groups
TARGET_HOST="$(awk '/^\\[staging\\]/{flag=1;next}/^\\[/{flag=0}flag && NF{print $1; exit}' "$INVENTORY" || true)"
if [[ -n "${TARGET_HOST}" ]]; then
  echo "→ SSH check to ${TARGET_HOST} ..."
  ssh -o StrictHostKeyChecking=no -i "$ANSIBLE_KEY" "${ANSIBLE_SSH_USER}@${TARGET_HOST##*=}" 'hostname' || true
fi

# Run the playbook
ANSIBLE_HOST_KEY_CHECKING=False \
ANSIBLE_COLLECTIONS_PATHS="./collections:$HOME/.ansible/collections:/usr/share/ansible/collections" \
ansible-playbook -i "$INVENTORY" "$PLAYBOOK" \
  -l "$DEPLOY_LIMIT" \
  --private-key "$ANSIBLE_KEY" \
  -e "$EXTRA_VARS" \
  -e "ansible_user=${ANSIBLE_SSH_USER}" \
  -e "ansible_ssh_common_args='-o StrictHostKeyChecking=no'"

echo "✓ Ansible deploy step completed."
'''
      }
    }
  }
}
  }

  post {
    success { echo "✅ ${env.APP_NAME} ${env.IMAGE_TAG} built (BE/FE) & deployed via Swarm + NGINX." }
    failure { echo "❌ Pipeline failed. See console log." }
  }
}
