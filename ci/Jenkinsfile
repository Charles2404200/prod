pipeline {
  agent any
  options { skipDefaultCheckout(true) }

  parameters {
    string(name: 'GHCR_NAMESPACE',  defaultValue: 'BennyBach1002', description: 'GitHub user/org (lowercase for Docker)')
    string(name: 'BRANCH_TO_BUILD', defaultValue: 'ansible-test',  description: 'Git branch to build')
    string(name: 'DEPLOY_LIMIT',    defaultValue: 'localhost',     description: 'Ansible --limit (use localhost to deploy on Jenkins host)')
  }

  environment {
    APP_NAME  = 'rmit-store'
    INVENTORY = 'infra/ansible/inventory.ini'
    PLAYBOOK  = 'infra/ansible/site.yml'
  }

  stages {

    stage('Checkout into ws/') {
      steps {
        sh 'rm -rf ws && mkdir -p ws'
        checkout([$class: 'GitSCM',
          branches: [[name: "*/${params.BRANCH_TO_BUILD}"]],
          userRemoteConfigs: [[url: 'https://github.com/Charles2404200/prod']],
          extensions: [[ $class: 'RelativeTargetDirectory', relativeTargetDir: 'ws' ]]
        ])
        sh 'ls -la ws | head -n 30'
      }
    }

    stage('Login to GHCR') {
      steps {
        withCredentials([ usernamePassword(credentialsId: 'GHCR_USER',
                                           usernameVariable: 'GH_USER',
                                           passwordVariable: 'GH_TOKEN') ]) {
          sh 'echo "$GH_TOKEN" | docker login ghcr.io -u "$GH_USER" --password-stdin'
        }
      }
    }

    stage('Build & Push Images (FE/BE/DB)') {
      steps {
        dir('ws') {
          script {
            def ns  = params.GHCR_NAMESPACE.toLowerCase().replaceAll(/[^a-z0-9-]/, '')
            def TAG = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()

            def BACKEND  = "ghcr.io/${ns}/rmit-store-backend"
            def FRONTEND = "ghcr.io/${ns}/rmit-store-frontend"
            def DBIMG    = "ghcr.io/${ns}/rmit-store-db"

            sh """
              set -e
              echo Building tag ${TAG}

              # Backend
              docker build --pull --no-cache -t ${BACKEND}:${TAG}  -f ci/Dockerfile.backend .
              docker tag ${BACKEND}:${TAG} ${BACKEND}:latest
              docker push ${BACKEND}:${TAG}
              docker push ${BACKEND}:latest

              # Frontend
              docker build --pull --no-cache -t ${FRONTEND}:${TAG} -f ci/Dockerfile.frontend .
              docker tag ${FRONTEND}:${TAG} ${FRONTEND}:latest
              docker push ${FRONTEND}:${TAG}
              docker push ${FRONTEND}:latest

              # Database (use upstream image re-tag; replace with your own Dockerfile if needed)
              docker pull mongo:6
              docker tag  mongo:6 ${DBIMG}:${TAG}
              docker tag  mongo:6 ${DBIMG}:latest
              docker push ${DBIMG}:${TAG}
              docker push ${DBIMG}:latest

              docker image prune -f || true
            """

            env.IMAGE_TAG      = TAG
            env.BACKEND_IMAGE  = BACKEND
            env.FRONTEND_IMAGE = FRONTEND
            env.DB_IMAGE       = DBIMG
          }
        }
      }
    }

stage('Deploy with Ansible (Swarm + NGINX on EC2 via SSH)') {
  steps {
    withCredentials([
      usernamePassword(
        credentialsId: 'GHCR_USER',
        usernameVariable: 'GH_USER',
        passwordVariable: 'GH_TOKEN'
      ),
      sshUserPrivateKey(
        credentialsId: 'jenkins-ec2-key', // <-- your screenshot credential
        keyFileVariable: 'ANSIBLE_KEY',
        usernameVariable: 'CREDS_USER'     // we won't use this username
      )
    ]) {
      dir('ws') {
        sh '''#!/usr/bin/env bash
set -euo pipefail

INVENTORY="${INVENTORY:-infra/ansible/inventory.ini}"
PLAYBOOK="${PLAYBOOK:-infra/ansible/site.yml}"

# Force the real EC2 SSH user. Change to 'ubuntu' if your AMI is Ubuntu.
SSH_USER="ec2-user"

echo "Workspace: $(pwd)"
echo "Inventory: ${INVENTORY}"
echo "Playbook : ${PLAYBOOK}"
echo "Using SSH user: ${SSH_USER}"

export PATH="$HOME/.local/bin:$PATH"

# Ensure Ansible
if ! command -v ansible-playbook >/dev/null 2>&1; then
  if command -v yum >/dev/null 2>&1; then
    sudo yum install -y python3-pip || true
  elif command -v apt-get >/dev/null 2>&1; then
    sudo apt-get update -y && sudo apt-get install -y python3-pip || true
  fi
  python3 -m pip install --user "ansible>=9,<10"
fi

# Preflight: SSH to localhost with the key as the right user
echo "Preflight SSH → ${SSH_USER}@127.0.0.1"
ssh -i "$ANSIBLE_KEY" -o StrictHostKeyChecking=no -o BatchMode=yes \
    "${SSH_USER}@127.0.0.1" 'echo "SSH ok: $(whoami) on $(hostname)"'

# Login GHCR so the host can pull private images
echo "$GH_TOKEN" | docker login ghcr.io -u "$GH_USER" --password-stdin

export ANSIBLE_STDOUT_CALLBACK=yaml
export ANSIBLE_HOST_KEY_CHECKING=False

ansible-playbook -i "${INVENTORY}" "${PLAYBOOK}" \
  -l build \
  --private-key "${ANSIBLE_KEY}" \
  -u "${SSH_USER}" \
  -e "frontend_image=${FRONTEND_IMAGE}" \
  -e "backend_image=${BACKEND_IMAGE}" \
  -e "db_image=${DB_IMAGE}" \
  -e "image_tag=${IMAGE_TAG}" \
  -e "app_name=${APP_NAME}" \
  -e "env=staging" \
  -e "ghcr_user=${GH_USER}" \
  -e "ghcr_token=${GH_TOKEN}" \
  -e "frontend_published=18080" \
  -e "backend_published=3000" \
  -e "skip_backend_wait=true"

echo "✓ Swarm deploy finished."
'''
      }
    }
  }
}
  }

  post {
    success { echo "✅ ${env.APP_NAME} ${env.IMAGE_TAG} built & deployed to Swarm (host Nginx on :80)." }
    failure { echo "❌ Pipeline failed. Check console log." }
  }
}
