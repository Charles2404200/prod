pipeline {
  agent any
  options {
    skipDefaultCheckout(true)
  }

  parameters {
    string(name: 'GHCR_NAMESPACE',  defaultValue: 'BennyBach1002', description: 'GitHub user/org (lowercased for Docker)')
    string(name: 'BRANCH_TO_BUILD', defaultValue: 'ansible-prod',  description: 'Git branch to build')
    string(name: 'DEPLOY_LIMIT',    defaultValue: 'lb,staging',    description: 'Ansible --limit (e.g. "lb,staging" or "lb,prod")')
    booleanParam(name: 'DOCKER_SWARM', defaultValue: false, description: 'Run the Docker Swarm deploy stage (leave off if not set up)')
  }

  environment {
    APP_NAME = 'rmit-store'

    // Repo
    REPO_URL = 'https://github.com/Charles2404200/prod'

    // Ansible inside repo
    INVENTORY_PATH = 'infra/ansible/inventory.ini'
    PLAYBOOK_PATH  = 'infra/ansible/site.yml'

    // Controller EC2 (where Ansible runs)
    CTRL_HOST   = '34.227.19.111'
    CTRL_USER   = 'ec2-user'
    REMOTE_WORK = '/home/ec2-user/deploy'

    // App runtime config
    FRONTEND_DOMAIN = '34.227.19.111'         // where UI should be reachable
    JWT_SECRET = 'my_secret_string'
    MONGO_URI  = 'mongodb+srv://RMIT_Store:123RMIT@ac-mr6vgxa-shard-00-00.uvixzgs.mongodb.net/admin?authSource=admin&replicaSet=atlas-gbr5dj-shard-0&retryWrites=true&w=majority&appName=RMITStore'

    NGINX_IMG = 'nginx:1.27-alpine'
  }

  stages {

    stage('Checkout') {
      steps {
        sh 'rm -rf ws && mkdir -p ws'
        checkout([$class: 'GitSCM',
          branches: [[name: "*/${params.BRANCH_TO_BUILD}"]],
          userRemoteConfigs: [[url: "${env.REPO_URL}"]],
          extensions: [[ $class: 'RelativeTargetDirectory', relativeTargetDir: 'ws' ]]
        ])
        sh 'ls -la ws | head -n 30'
      }
    }

    stage('Resolve Image Names & Tag') {
      steps {
        script {
          def ns = params.GHCR_NAMESPACE.trim().toLowerCase()
          env.FE_IMG = "ghcr.io/${ns}/rmit-store-frontend".toLowerCase()
          env.BE_IMG = "ghcr.io/${ns}/rmit-store-backend".toLowerCase()
          env.IMAGE_TAG = sh(returnStdout: true, script: 'cd ws && git rev-parse --short HEAD').trim()
          if (!env.IMAGE_TAG) { env.IMAGE_TAG = "build-${env.BUILD_NUMBER}" }
          echo "FE_IMG=${env.FE_IMG}"
          echo "BE_IMG=${env.BE_IMG}"
          echo "IMAGE_TAG=${env.IMAGE_TAG}"
        }
      }
    }

    stage('Login to GHCR') {
      steps {
        withCredentials([ usernamePassword(credentialsId: 'GHCR_USER',
                                           usernameVariable: 'GH_USER',
                                           passwordVariable: 'GH_TOKEN') ]) {
          sh 'echo "$GH_TOKEN" | docker login ghcr.io -u "$GH_USER" --password-stdin'
        }
      }
    }

stage('Build & Push Images') {
  steps {
    withCredentials([ usernamePassword(credentialsId: 'GHCR_USER',
                                       usernameVariable: 'GH_USER',
                                       passwordVariable: 'GH_TOKEN') ]) {
      dir('ws') {
        sh '''#!/usr/bin/env bash
          set -euo pipefail

          echo "[debug] show dockerfiles and key dirs"
          ls -la | sed -n '1,120p'
          ls -la client | sed -n '1,120p' || true

          # ---- Backend ----
          # Context: repo root (package.json for backend is here)
          # Dockerfile: Dockerfile.backend
          echo "[build] Backend -> $BE_IMG:$IMAGE_TAG"
          docker build \
            -f Dockerfile.backend \
            -t "$BE_IMG:$IMAGE_TAG" \
            .

          # ---- Frontend ----
          # Context: client/ (frontend package.json lives here)
          # Dockerfile: Dockerfile.frontend
          echo "[build] Frontend -> $FE_IMG:$IMAGE_TAG"
          docker build \
            -f Dockerfile.frontend \
            -t "$FE_IMG:$IMAGE_TAG" \
            client

          echo "[push] $BE_IMG:$IMAGE_TAG"
          docker push "$BE_IMG:$IMAGE_TAG"

          echo "[push] $FE_IMG:$IMAGE_TAG"
          docker push "$FE_IMG:$IMAGE_TAG"
        '''
      }
    }
  }
}


    stage('Deploy (Docker Swarm)') {
      when { expression { return params.DOCKER_SWARM } }
      steps {
        echo "Swarm deploy is enabled (add your stack deploy once Swarm is configured)."
      }
    }

  } // stages

  post {
    success { echo "✅ ${env.APP_NAME} ${env.IMAGE_TAG} built & deployed (Ansible). Swarm: ${params.DOCKER_SWARM ? 'ON' : 'OFF'}" }
    failure { echo "❌ Pipeline failed. Check logs above." }
    always  { echo "Build URL: ${env.BUILD_URL}" }
  }
}
